#####
#' F-test on Multiple Linear Combinations of Estimated Parameters in a Linear Model
#'
#' @description Performs an F-test (non-directional) on multiple (L) linear combinations of parameters in a linear model.
#'
#' @param mod model object estimated by \code{ols()} or \code{lm()}.
#' @param data name of the data frame to be used if \code{mod} is only a formula.
#' @param nh matrix of the coefficients of the linear combination of parameters. Each of the L rows of that matrix represents a linear combination.
#' @param q L-dimensional vector of values on which the parameter (combination) is to be tested against. Default value is the null-vector.
#' @param sig.level significance level. Default value: \code{sig.level = 0.05}.
#' @param details logical value indicating whether specific details about the test should be returned.
#' @param hyp logical value indicating whether the hypotheses should be part of the output. To be disabled if output is too large.
#'
#' @details
#' Objects x generated by \code{par.f.test} can be plotted using \code{plot(x, plot.what = ...)}. Argument \code{plot.what} can have the following values:
#' \tabular{ll}{
#' \code{"dist"} \tab plot the null distribution, test statistics and p-values.\cr
#' \code{"ellipse"} \tab plot acceptance ellipse.\cr
#' }
#' If \code{plot.what = "ellipse"} is specified, further arguments can be passed to \code{plot()}:
#' \tabular{ll}{
#' \code{type = "acceptance"} \tab plot acceptance ellipse ("acceptance") or confidence ellipse ("confidence").\cr
#' \code{which.coef = c(2,3)} \tab for which two coefficients should the ellipse be plotted?\cr
#' \code{center = TRUE} \tab plot center of ellipse.\cr
#' \code{intervals = TRUE} \tab	plot interval borders.\cr
#' \code{test.point = TRUE} \tab plot the point (q-values or coefficients) used in F-Test.\cr
#' \code{q = c(0,0)} \tab	the q-value used in acceptance ellipse.\cr
#' \code{sig.level = 0.05} \tab	significance level used.\cr
#' }
#'
#' @return A list object including:
#' \tabular{ll}{
#' \code{hyp} \tab character matrix of hypotheses (if \code{hyp = TRUE}).\cr
#' \code{nh} \tab linear combinations tested in the null hypothesis (in matrix form).\cr
#' \code{q} \tab vector of values the linear combinations are tested on.\cr
#' \code{mod} \tab the model passed to \code{par.f.test}.\cr
#' \code{results} \tab a data frame of basic test results.\cr
#' \code{SSR.H0} \tab sum of squared residuals in H0-model.\cr
#' \code{SSR.H1} \tab sum of squared residuals in regular model.\cr
#' \code{nulldist}\tab type of the null distribution with its parameters.\cr
#' }
#'
#' @export
#'
#' @importFrom stats coef
#'
#' @examples
#' ## H0: beta1 = 0.33 and beta2 = 0
#' x <- par.f.test(barley ~ phos + nit, data = log(data.fertilizer),
#'                  nh = rbind(c(0,1,0), c(0,0,1)),
#'                  q = c(0.33,0.33),
#'                  details = TRUE)
#' x # Show the test results
#'
#' plot(x) # Visualize the test result
#' plot(x, plot.what = "ellipse", q = c(0.33, 0.33))
#'
#' @concept F-test
#' @concept linear combination
#' @concept linear hypothesis
#' @concept linear model
#'
#####
par.f.test = function(mod,
                       data = list(),
                       nh,
                       q = rep(0,dim(nh)[1]),
                       sig.level = 0.05,
                       details = FALSE,
                       hyp = TRUE){

  if (inherits(mod, "formula")) { # Wenn Formel Ã¼bergeben ...
    mod = ols(mod, data = data)
  }

  nh = as.matrix(nh)
  if (dim(nh)[2] == 1) nh = t(nh) # If a t-test
  L = dim(nh)[1]
  SSR = sum(mod$residuals^2)
  df = mod$df.residual # T-K-1
  X = model.matrix(mod) # Extrahiere Praediktoren (inkl alpha)
  XXi = chol2inv(chol(t(X)%*%X))
  bhat = coef(mod)
  coefnames = names(bhat)

  # Calculate F-Value
  f.val = t(nh %*% bhat-q) %*% chol2inv(chol(nh %*% XXi %*% t(nh))) %*% (nh %*% bhat-q)/(L*SSR/df)

  ## Generate Hypotheses
  if (hyp) {
  H = matrix(NA, dim(nh)[1], 2L)
  for (j in 1:L){ # for all hypotheses
    h = ""
    R = nh[j,] # get row j of nh-matrix
    for (i in 1:length(coefnames)){
      tmp = coefnames[i]
      if (R[i] != 0){ # If coef not zero...
        tmp = paste(as.character(abs(R[i])),"*",tmp, sep = "")
        tmp = paste(if ((R[i]>0) & (h != "")) " + " else if (R[i]<0) " - ", tmp, sep = "")
      } else {tmp = ""}# If coef zero, then no name
      h = paste(h, tmp, sep = "")
    } # end of inner for
    h = c(paste(h, " = ", q[j], sep = ""),paste(h, " <> ", q[j], sep = ""))
    H[j,] = h
  } # end of outer for
  dimnames(H) = list(1:L, c("H0:", "H1:"))
  } else {
    H = NULL
  }

  ## Generate other data
  f.crit = qf(1 - sig.level, L, df)
  p.val = 1 - pf(f.val, L, df)

  test.result = if (p.val < sig.level) "rejected" else "not rejected"
  results = data.frame(f.value = f.val,
                       crit.value = f.crit,
                       p.value = p.val,
                       sig.level = sig.level,
                       H0 = test.result,
                       row.names = "")

  out = list()
  attr(out, "title") = "F-Test on multiple linear combinations of parameters"
  out$hyp = H # Null and alternative hypothesis
  out$nh = nh # Null and alternative hypothesis (Matrix form)
  out$q = q # q-value (default: 0)
  out$results = results # Basic test results
  out$mod = mod # Model behind the test
  out$SSR.H0 = SSR*(f.val*L/df + 1)
  out$SSR.H1 = SSR
  out$nulldist = list(type = "f", df = c(L,df))

  attr(out, "direction") = "right"
  attr(out, "details") = if (details) {T} else {F}
  attr(out, "type") = "htest"
  attr(out, "test.type") = "ftest"
  class(out) = c("desk")

  return(out)
}
