#####
#' Ordinary Least Squares Regression
#'
#' @description Estimates linear models using ordinary least squares estimation. Generated objects should be compatible with commands expecting objects generated by \code{lm()}. The object returned by this command can be plotted using the \code{plot()} function.
#'
#' @param formula model formula.
#' @param data name of data frame of variables in \code{formula}.
#' @param na.action function which indicates what should happen when the data contain NAs.
#' @param contrasts an optional list. See the \code{contrasts.arg} of \code{\link[stats]{model.matrix.default}}.
#' @param details logical value indicating whether details should be printed out by default.
#' @param ... other arguments that \code{lm.fit()} supports.
#'
#' @details Let X be a model object generated by \code{ols()} then \code{plot(X, ...)} accepts the following arguments:
#' \tabular{ll}{
#' \code{pred.int = FALSE} \tab should prediction intervals be added to plot?\cr
#' \code{conf.int = FALSE} \tab should confidence intervals be added to plot?\cr
#' \code{residuals = FALSE} \tab should residuals be added to plot?\cr
#' \code{center = FALSE} \tab should mean values of both variables be added to plot?\cr
#' }
#'
#' @return A list object including:
#' \tabular{ll}{
#' \code{coefficients/coef} \tab estimated parameters of the model.\cr
#' \code{residuals/resid} \tab residuals of the estimation.\cr
#' \code{effects} \tab n vector of orthogonal single-df effects. The first rank of them correspond to non-aliased coefficients, and are named accordingly.\cr
#' \code{fitted.values} \tab fitted values of the regression line.\cr
#' \code{df.residual/df} \tab degrees of freedom in the model (number of observations minus rank).\cr
#' \code{se} \tab vector of standard errors of the parameter estimators.\cr
#' \code{t.value} \tab vector of t-values of single parameter significance tests.\cr
#' \code{p.value} \tab vector of p-values of single parameter significance tests.\cr
#' \code{data/model} \tab matrix of the variables' data used.\cr
#' \code{response} \tab the endogenous (response) variable.\cr
#' \code{model.matrix} \tab the model (design) matrix.\cr
#' \code{ssr} \tab sum of squared residuals.\cr
#' \code{sig.squ} \tab estimated error variance (sigma squared).\cr
#' \code{vcov} \tab the variance-covariance matrix of the model's estimators.\cr
#' \code{r.squ} \tab coefficient of determination (R squared).\cr
#' \code{adj.r.squ} \tab adjusted coefficient of determination (adj. R squared).\cr
#' \code{nobs} \tab number of observations.\cr
#' \code{ncoef/rank} \tab integer, giving the rank of the model (number of coefficients estimated).\cr
#' \code{has.const} \tab logical value indicating whether model has constant parameter.\cr
#' \code{f.val} \tab F-value for simultaneous significance of all slope parameters.\cr
#' \code{f.pval} \tab p-value for simultaneous significance of all slope parameters.\cr
#' \code{modform} \tab the model's regression R-formula.\cr
#' \code{call} \tab the function call by which the regression was calculated (including \code{modform}).\cr
#' }
#'
#' @export
#'
#' @importFrom stats .getXlevels as.formula is.empty.model model.frame model.matrix model.response na.omit pf pt
#'
#' @examples
#' ## Minimal simple regression model
#' check <- c(10,30,50)
#' tip <- c(2,3,7)
#' tip.est <- ols(tip ~ check)
#'
#' ## Equivalent estimation using data argument
#' tip.est <- ols(y ~ x, data = data.tip)
#'
#' ## Show estimation results
#' tip.est
#'
#' ## Show details
#' print(tip.est, details = TRUE)
#'
#' ## Plot scatter and regression line
#' plot(tip.est)
#'
#' ## Plot confidence (dark) and prediction bands (light), residuals and two center lines
#' plot(tip.est, pred.int = TRUE, conf.int = TRUE, residuals = TRUE, center = TRUE)
#'
#' ## Multiple regression model
#' fert.est <- ols(barley ~ phos + nit, data = log(data.fertilizer), details = TRUE)
#' fert.est
#'
#' @concept ordinary least squares, linear model, regression
#'
#####
ols = function(formula, data = list(), na.action = NULL, contrasts = NULL, details = FALSE, ...){

  # simulate "lm"-call for stargazer compatibility
  cl = match.call()
  cl[1] = as.call(list(quote(lm)))

  dname = paste(deparse(substitute(data)))

  mf = model.frame(formula, data = data, drop.unused.levels = TRUE) # Data matrix
  mt = attr(mf, "terms") # Model terms
  y = model.response(mf, "numeric") # Response data
  #y = as.matrix(y)
  #colnames(y) = colnames(mf)[1]
  X = model.matrix(mt, mf, contrasts) # Regressor data
  n = nrow(X) # Number of observations
  k = ncol(X) # Number of coefs in the model
  df = n - k # Number of coefs in the model

  # Perfect Collinearity
  qr.decomp <- qr(X)
  diag.upper <- diag(qr.decomp$qr)[1:min(dim(X))]
  if (any(abs(diag.upper) < 1e-10)) {
    stop("There is the problem of perfect collinearity.", call. = F)
  }

  # Regression
  if (!is.empty.model(mt)) {
    out = as.list(lm.fit(X, y, singular.ok = TRUE, ...))
    ssr = sum(out$residuals^2)
    sig.squ = ssr/out$df.residual
    bhat = out$coefficients
    coefnames = names(bhat)
    XXi = chol2inv(chol(t(X) %*% X))
    VC = sig.squ * XXi
    dimnames(VC) = list(coefnames,coefnames)

    out$modform = paste(deparse(mt), collapse = "")
    attr(out, "title") = if(nchar(out$modform) < 50){
      paste("OLS-Regression of model", paste("", out$modform, "", sep = ""))} else {
      "OLS-Regression"}
    out$model.formula = as.formula(out$modform)

    # Regression table splitted
    #out$coef = out$coefficients
    out$std.err = sqrt(diag(VC))
    out$t.value = out$coef/out$std.err
    out$p.value = 2*pt(-abs(out$t.value), df = df)

    # Data
    out$data = mf # Used dataframe
    out$data.name = dname # Name of used dataframe
    out$response = y
    out$model.matrix = X

    # Some statistics
    out$ssr = ssr
    out$sig.squ = sig.squ
    out$vcov = VC
    out$r.squ = Sxy(out$fitted.values)/Sxy(y)
    out$adj.r.squ = 1-(1-out$r.squ)*(n-1)/df

    # Misc
    out$nobs = n
    out$ncoef = k
    out$has.const = if (attr(mt,"intercept") == 0){F} else if (attr(mt,"intercept") == 1){T}

    # F Test
    if(out$has.const){nh = diag(k)[-1,]; k0 = 1} else {nh = diag(k); k0 = 0}
    if (k == 2) {nh = t(as.matrix(nh))}
    if((k-k0) > 0){
    out$f.value = t(nh %*% bhat) %*% chol2inv(chol(nh %*% XXi %*% t(nh))) %*% (nh %*% bhat)/((k-k0)*ssr/df)
    out$f.pvalue = 1-pf(out$f.val, k-k0, df)
    }

    # for lm compatibility
    out$na.action = attr(mf, "na.action")
    out$contrasts = attr(X, "contrasts")
    out$xlevels = .getXlevels(mt, mf)
    out$call = cl
    out$terms = mt
    out$model = mf
    #out$offset = offset
  }
  else {
    stop("Empty models not supported.", call. = F)
  }

  out = out[order(names(out))]

  attr(out, "details") = if (details) {T} else {F}
  attr(out, "type") = "ols"
  class(out) = c("desk", "lm")

  return(out)
}
