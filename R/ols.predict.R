#####
#' Predictions in a Linear Model
#'
#' @description Calculates the predicted values of a linear model based on specified values of the exogenous variables. Optionally the estimated variance of the prediction error is returned.
#'
#' @param mod model object generated by \code{ols()} or \code{lm()}.
#' @param data name of data frame to be specified if \code{mod} is a formula.
#' @param xnew (T x K) matrix of new values of the exogenous variables, for which a prediction should be made, where \code{K} is the number of exogenous variables in the model \code{T} is the number of predictions to be made. If \code{xnew} is not specified, the fitted values are returned.
#' @param antilog logical value which indicates whether to re-transform the predicted value of a log transformed dependent variable back into original units.
#' @param details logical value, if specified as \code{TRUE}, a list is returned, which additionally includes the estimated variance of the prediction error (\code{var.pe}), estimated variance of the error term (\code{sig.squ}), and the estimated sampling error (\code{smpl.err}).
#'
#' @return A list object including:
#' \tabular{ll}{
#'   \code{pred.val} \tab the predicted values.\cr
#'   \code{xnew} \tab values of predictor at which predictions should be evaluated.\cr
#'   \code{var.pe} \tab estimated variance of prediction error.\cr
#'   \code{sig.squ} \tab estimated variance of error term.\cr
#'   \code{smpl.err} \tab estimated sampling error.\cr
#'   \code{mod} \tab the model estimated (for internal purposes)\cr
#' }
#'
#' @export
#'
#' @examples
#' ## Estimate logarithmic model
#' fert.est <- ols(barley ~ phos + nit, data = log(data.fertilizer))
#'
#' ## Set new x data
#' my.mat = cbind(x1 = log(c(6,3,9)), x2 = log(c(5,3,10)))
#'
#' ## Returns fitted values
#' ols.predict(fert.est)
#'
#' ## Returns predicted values at new x-values
#' ols.predict(fert.est, xnew = my.mat)
#'
#' ## Returns re-transformed predicted values and est. var. of pred. error
#' ols.predict(fert.est, xnew = my.mat, antilog = TRUE, details = TRUE)
#'
#' @concept predicted values
#' @concept linear model
#'
#####
ols.predict = function(mod, data = list(), xnew, antilog = FALSE, details = FALSE){

  if (inherits(mod, "formula")) { # Wenn Formel übergeben ...
    mod = ols(mod, data = data)
  }

  if (missing(xnew)){xnew = as.matrix(mod$data[,-1])}
  xnew = as.matrix(xnew)

  if(dim(xnew)[1] > 1 & dim(xnew)[2] == 1) xnew = t(xnew) # convert column vector to row vector

  co = coef(mod) # Übergebene Koeffizienten
      if(mod$ncoef - sum(ols.has.const(mod)) == dim(xnew)[2]){
        if(ols.has.const(mod)){
          xnew = cbind(rep(1,dim(xnew)[1]),xnew) # Füge Vektor von Einsen ein
        }
        val = as.vector(xnew %*% co) # Fitted values
        if (antilog){# Korrekturfaktor bei log(y)
          cf = exp(mod$sig.squ/2)
          val = exp(val) * cf
          message(paste("Predicted value corrected by factor",cf))
        }

        sig2 = mod$sig.squ # Sigma^2
        varpe = diag(xnew %*% vcov(mod) %*%t (xnew)) + sig2 # Standardabw. Prognosefehler

        out = list(pred.val = val)
        if(ols.has.const(mod)){xnew = xnew[,-1]}
        out$xnew = xnew
        out$var.pe = varpe
        out$sig.squ = sig2
        out$smpl.err = varpe - sig2
        out$mod = mod


        attr(out, "title") = NULL
        attr(out, "details") = if (details) {T} else {F}
        attr(out, "type") = "pred"
        class(out) = c("desk")

      } else {
        stop("xnew must be (T x K) where T is the  number of predictions,
                and K is the number of exogenous predictors", call. = F)
      }
  return(out)
}
