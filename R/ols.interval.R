#####
#' Calculate Different Types of Intervals in a Linear Model
#'
#' @description Calculates different types of intervals in a linear model.
#'
#' @param mod linear model object generated by \code{ols()}.
#' @param data name of data frame to be specified if mod is a formula.
#' @param type string value indicating the type of interval to be calculated. Default is "confidence".
#' @param which.coef strings of variable name(s) or vector of indices indicating the coefficients in the linear model for which confidence or acceptance intervals should be calculated. By default all coefficients are selected. Ignored for prediction intervals.
#' @param sig.level significance level.
#' @param q value against which null hypothesis is tested. Only to be specified if type = "acceptance".
#' @param dir direction of the alternative hypothesis underlying the acceptance intervals. One sided confidence- and prediction intervals are not (yet) supported.
#' @param xnew (T x K) matrix of new values of the exogenous variables, at which interval should be calculated, where T is the number of exogenous data points at which intervals should be calculated K is the number of exogenous variables in the model If type = "prediction" then prediction intervals are calculated at xnew, if type = "confidence" then confidence intervals around the unknown true y-values are calculated at xnew (ak.a. confidence band). Ignored if type = "acceptance". In multiple regression models variable names must be specified.
#' @param details logical value indicating whether details (estimated standard deviations) should be printed out.
#'
#' @return A list object including:
#' \tabular{ll}{
#' \code{results} \tab interval borders (lower and upper) and center of interval (if \code{dir = "both"}).\cr
#' \code{std.err} \tab estimated standard deviations.\cr
#' \code{t.value} \tab critical t-value.\cr
#' }
#'
#' @export
#'
#' @examples
#' fert.est <- ols(barley ~ phos + nit, data = log(data.fertilizer))
#' my.mat = cbind(x1 = log(c(6,3,9)), x2 = log(c(5,3,10)))
#'
#' ## 95% CI for all parameters
#' ols.interval(fert.est)
#'
#' ## 95% CI for intercept and beta2
#' ols.interval(fert.est, which.coef = c(1,3))
#'
#' ## 95% CI around three true, constant y-values
#' ols.interval(fert.est, xnew = my.mat)
#'
#' ## AI for H0:beta1 = 0.5 and H0:beta2 = 0.5
#' ols.interval(fert.est, type = "acc", which.coef = c(2,3), q = 0.5)
#'
#' ## AI for H0:beta1 <= 0.5
#' ols.interval(fert.est, type = "acc", which.coef = 2, dir = "right", q = 0.5)
#'
#' ## PI (Textbook p. 285)
#' ols.interval(fert.est, type = "pred", xnew = c(x1 = log(29), x2 = log(120)), details = TRUE)
#'
#' ## Three PI
#' ols.interval(fert.est, type = "pred", xnew = my.mat, details = TRUE)
#'
#' @concept confidence interval, acceptance interval, prediction interval, linear model
#'
#####
ols.interval = function(mod,
                        data = list(),
                        type = c("confidence", "prediction", "acceptance"),
                        which.coef = "all",
                        sig.level = 0.05,
                        q = 0,
                        dir = c("both", "left", "right"),
                        xnew,
                        details = FALSE){

  if (inherits(mod, "formula")) { # Wenn Formel 체bergeben ...
    mod = ols(mod, data = data)
  }

  if(!(inherits(mod,"desk") | (attr(mod, "type") == "ols"))){
    stop("Model is not compatible. Please use object generated by ols() from package desk.", call. = F)
  }

  type = match.arg(type)
  dir = match.arg(dir)

  # Function to convert percentage
  format.perc = function(probs, digits){
    paste(format(100 * probs, trim = TRUE, scientific = FALSE, digits = digits),
          "%", sep = "")
    }

  co = mod$coefficients # Uebergebene Koeffizienten
  cn = names(co) # Extrahiere Namen

  # Wenn keine Parameter angegeben, w채hle alle...
  if(length(which.coef) == 1){if(which.coef == "all"){which.coef = cn}} else {
    if(is.numeric(which.coef)) {which.coef = cn[which.coef]}
  }

  # Case: direction = "both"
  a = c(sig.level/2, 1 - sig.level/2)
  tval = qt(a, mod$df)
  header = c("center", format.perc(a, 3))
  out = array(NA, dim = c(length(which.coef), 3L))

  ##############################
  # Confidence intervals #######
  ##############################
  if (type == "confidence"){
    if (dir != "both") stop("One-sided confidence intervals are not supported.", call. = F)
    if (missing(xnew)){ # CI for model's parameter
      #message("No xnew was specified. Will calculate confidence intervals for the model's parameters ...", call. = F)
      se = sqrt(diag(mod$vcov)[which.coef])
      out = cbind(co[which.coef], co[which.coef] + se %o% tval)
      colnames(out) = header
      c.type = "ci.beta"
    } else { # CI for model's expected y-value
      if (inherits(xnew, "numeric")){xnew = t(xnew)}
      if(mod$ncoef - sum(mod$has.const) == dim(xnew)[2]){
      if(ols.has.const(mod)){
        xnew = cbind(1,xnew) # F체ge Vektor von Einsen ein
        }
      ynew = as.vector(xnew %*% co) # Fitted values
      se = sqrt(diag(xnew %*% mod$vcov %*% t(xnew))) # Vektor von quadratischen Formen
      out = cbind(ynew, ynew + se %o% tval)
      dimnames(out) = list(1:dim(xnew)[1], header)
      c.type = "ci.y"
      } else {
        stop("xnew must be (T x K) where K is the number of predictors", call. = F)
      }
    }
  }

  ##############################
  # Prediction intervals #######
  ##############################
  if (type == "prediction"){
    if (dir != "both") stop("One-sided prediction intervals are not supported.", call. = F)
    if (missing(xnew)){
      # warning("No xnew was specified. Will use given observations for prediction.", call. = F)
      xnew = as.matrix(mod$data[,-1])
    }
    if (inherits(xnew, "numeric")){xnew = t(xnew)}
    if(mod$ncoef - sum(mod$has.const) == dim(xnew)[2]){
      if(ols.has.const(mod)){
        xnew = cbind(1,xnew) # F체ge Vektor von Einsen ein
      }
      ynew = as.vector(xnew %*% co) # Fitted values
      se = sqrt(diag(xnew %*% mod$vcov %*% t(xnew)) + mod$sig.squ) # Vektor von quadratischen Formen
      out = cbind(ynew, ynew + se %o% tval)
      dimnames(out) = list(1:dim(xnew)[1], header)
      c.type = "pi"
    } else {
      stop("xnew must be (T x K) where K is the number of predictors", call. = F)
    }
  }

  ##############################
  # Acceptance intervals #######
  ##############################
  if (type == "acceptance"){
    se = sqrt(diag(mod$vcov)[which.coef])
    switch(dir,
           both = {
             out = cbind(q, q + se %o% tval)
           },
           right = {
             tval = qt(1-sig.level, mod$df)
             header = c("lower", format.perc(1-sig.level, 3))
             out = cbind(-Inf, q + se %o% tval)
           },
           left = {
             tval = qt(sig.level, mod$df)
             header = c(format.perc(sig.level, 3), "upper")
             out = cbind(q - se %o% tval, Inf)
           }
    )
    colnames(out) = header
    c.type = "ai"
  }

  out = list(results = out)
  out$std.err = se
  out$t.value = tval

  attr(out, "title") = NULL
  attr(out, "details") = if (details) {T} else {F}
  attr(out, "type") = "int"
  attr(out, "c.type") = c.type
  class(out) = c("desk")

return(out)
}
